<?php

namespace Drupal\commerce_cnpay\Plugin\Commerce\PaymentGateway;

use Drupal\commerce_cnpay\PluginForm\PaymentQueryForm;
use Drupal\commerce_order\Entity\OrderInterface;
use Drupal\commerce_payment\Entity\PaymentInterface;
use Drupal\commerce_payment\Exception\PaymentGatewayException;
use Drupal\commerce_payment\PaymentMethodTypeManager;
use Drupal\commerce_payment\PaymentTypeManager;
use Drupal\commerce_payment\Plugin\Commerce\PaymentGateway\OffsitePaymentGatewayBase;
use Drupal\commerce_payment\Plugin\Commerce\PaymentGateway\SupportsVoidsInterface;
use Drupal\commerce_price\Price;
use Drupal\Component\Datetime\TimeInterface;
use Drupal\Core\Config\ConfigFactoryInterface;
use Drupal\Core\Entity\EntityTypeManagerInterface;
use Drupal\Core\Logger\LoggerChannelFactoryInterface;
use Drupal\Core\Site\Settings;
use Drupal\Core\Url;
use GuzzleHttp\Exception\RequestException;

abstract class CNPaymentGatewayBase extends OffsitePaymentGatewayBase implements CNPaymentGatewayInterface {

  /**
   * Remote states (default to WeChat Pay).
   */
  const STATE_NOTPAY = 'not_pay';
  const STATE_CLOSED = 'closed';
  const STATE_REFUND = 'refund';
  const STATE_PARTIAL_REFUND = 'partial_refund';

  /**
   * The config factory.
   *
   * @var \Drupal\Core\Config\ConfigFactoryInterface
   */
  protected $configFactory;

  /**
   * The logger.
   *
   * @var \Drupal\Core\Logger\LoggerChannelInterface
   */
  protected $logger;

  /**
   * Constructs a new CNPaymentGatewayBase object.
   *
   * @param array $configuration
   *   A configuration array containing information about the plugin instance.
   * @param string $plugin_id
   *   The plugin_id for the plugin instance.
   * @param mixed $plugin_definition
   *   The plugin implementation definition.
   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
   *   The entity type manager.
   * @param \Drupal\commerce_payment\PaymentTypeManager $payment_type_manager
   *   The payment type manager.
   * @param \Drupal\commerce_payment\PaymentMethodTypeManager $payment_method_type_manager
   *   The payment method type manager.
   * @param \Drupal\Component\Datetime\TimeInterface $time
   *   The time.
   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
   *   The config factory.
   * @param \Drupal\Core\Logger\LoggerChannelFactoryInterface $logger_factory
   *   The logger factory.
   */
  public function __construct(array $configuration, $plugin_id, $plugin_definition, EntityTypeManagerInterface $entity_type_manager, PaymentTypeManager $payment_type_manager, PaymentMethodTypeManager $payment_method_type_manager, TimeInterface $time, ConfigFactoryInterface $config_factory, LoggerChannelFactoryInterface $logger_factory) {
    $this->configFactory = $config_factory;
    $this->logger = $logger_factory->get('commerce_cnpay');
    if (!isset($plugin_definition['forms'])) {
      $plugin_definition['forms'] = [];
    }
    $plugin_definition['forms'] += [
      'query-payment' => PaymentQueryForm::class,
    ];
    parent::__construct($configuration, $plugin_id, $plugin_definition, $entity_type_manager, $payment_type_manager, $payment_method_type_manager, $time);
  }

  /**
   * {@inheritdoc}
   */
  public function getSupportedModes() {
    $modes = parent::getSupportedModes();
    // The 'live_dev' will be appended to the out trade no and the refund no
    // for live development environment.
    $modes['live_dev'] = $this->t('Live - Development');
    return $modes;
  }

  /**
   * {@inheritdoc}
   */
  public function buildPaymentOperations(PaymentInterface $payment) {
    $operations = parent::buildPaymentOperations($payment); // TODO: Change the autogenerated stub
    $operations['query'] = [
      'title' => $this->t('Query'),
      'page_title' => $this->t('Query payment'),
      'plugin_form' => 'query-payment',
      'access' => TRUE,
    ];
    return $operations;
  }

  /**
   * {@inheritdoc}
   */
  public function getPrepayOpenidProvider() {
    return isset($this->pluginDefinition['prepay_openid_provider']) ? $this->pluginDefinition['prepay_openid_provider'] : FALSE;
  }

  /**
   * {@inheritdoc}
   *
   * @todo: set order number
   * @todo: query payment after 5 minutes if we did not receive an IPN.
   * @todo: change TTL of prepay_id and code_url from default 2h to something.
   *
   * We do create and save a payment object when prepaying to store the
   * transaction amount and generate the out trade no. Because we cannot relay
   * on the 'draft' order which will be refreshed (e.g., save it or load it
   * after 300s past) before a user complete the payment, that may result in a
   * failed payment verification when processing an incoming IPN, and we need a
   * mechanism to be able to generate multiple out trade no for an order, append
   * the payment id to the order id is a good way.
   *
   * @see verifyIpn()
   *
   * To make use of the existing out trade no, ensure the key payment parameters
   * do not change, for example WeChat:
   * 1. payment gateway : trade_type
   * 2. payment amount  : fee_type, total_fee
   * 3. body            : body
   * 4. other configurations like notify url, etc.
   *
   * We only explicitly handle the top 2 cases, for other cases just discard
   * the payment.
   */
  public function prepayPayment(PaymentInterface &$payment, array $params = NULL) {
    $this->assertPaymentState($payment, ['new']);

    if ($existing_payment = $this->loadPendingPayment($payment->getOrder())) {
      $this->assertPaymentState($existing_payment, ['authorization']);

      // We do some pre-check to discard the stale payment before we perform
      // a prepay API request, however this cannot cover all possible cases,
      // therefor we will also do it when the prepay fails.
      if (!$this->isPaymentReusable($existing_payment, $payment)) {
        $this->discardPayment($existing_payment, FALSE);
      }
      else {
        // Reuse the existing payment, thus we can reuse the out trade no
        // and no need to discard the old payment.
        $payment = $existing_payment;
      }
    }
    // Track if this entity is new and save it if TRUE to get its id.
    $is_new = $payment->isNew();
    if ($is_new) {
      $payment->save();
    }

    try {
      // Execute the prepay.
      $prepay_response = $this->doPrepayPayment($payment, $params);
      $this->logResponse('Prepay payment', $prepay_response, $this->getOutTradeNo($payment));
    }
    catch (RequestException $e) {
      if ($is_new) {
        // The new payment with state 'new 'is useless because no transaction
        // exists for it.
        $payment->delete();
      }
      throw new PaymentGatewayException(sprintf('%s Could not prepay payment: %s', $this->getLabel(), $e->getMessage()), $e->getCode(), $e);
    }

    if ($this->isPrepaySuccessful($prepay_response)) {
      // The transaction of gateway vendor is unknown in this phase, thus we
      // can't set the remote id to payment.

      // Update payment state and remote state, because we treat this payment as
      // a new one regardless of the probable old 'PAYERROR' remote state.
      $payment->setState('authorization');
      // @todo: For Alipay the state here should not be 'WAIT_BUYER_PAY' because the transaction is not created.
      $payment->setRemoteState($this->getRemoteState(self::STATE_NOTPAY));

      // Save the transaction information.
      $payment->save();
    }
    else {
      // In case of pre-check is not sufficient for example 'body', 'notify_url'
      // or any other configuration of WeChat are changed, discard this payment
      // and we will get a new out trade no next time.
      $this->discardPayment($payment, $is_new);
    }

    return $prepay_response;
  }

  /**
   * Loads a pending payment that awaits for pay for the given order.
   *
   * @param \Drupal\commerce_order\Entity\OrderInterface $order
   *   The order.
   *
   * @return \Drupal\commerce_payment\Entity\PaymentInterface|null
   *   A payment object, or NULL if no matching object is found.
   *
   * @throws \InvalidArgumentException
   *   Thrown when the order is not in draft state.
   */
  protected function loadPendingPayment(OrderInterface $order) {
    // Customers can't pay orders that have already been placed or cancelled.
    if ($order->getState()->value != 'draft') {
      throw new \InvalidArgumentException(sprintf('The provided order is in an invalid state ("%s").', $order->getState()->value));
    }

    /** @var \Drupal\commerce_payment\PaymentStorageInterface $storage */
    $storage = $this->entityTypeManager->getStorage('commerce_payment');
    $payments = $storage->loadByProperties([
      'order_id' => $order->id(),
      'state' => 'authorization',
    ]);
    $payment = reset($payments);

    return $payment ?: NULL;
  }

  /**
   * Whether the existing payment is reusable.
   *
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   The existing payment.
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $new_payment
   *   The new payment.
   *
   * @return bool
   *   TRUE if the existing payment is available for reuse, FALSE otherwise.
   */
  protected function isPaymentReusable(PaymentInterface $payment, PaymentInterface $new_payment) {
    // Payment gateway may change for example a user placed an order on mobile
    // web (JSAPI) and later pay the order on PC web (NATIVE).
    $same_gateway = $payment->getPaymentGatewayId() == $new_payment->getPaymentGatewayId();
    // Payment amount may change due to 'order refresh', because this is still
    // a draft order.
    $same_amount = $payment->getAmount()->equals($new_payment->getAmount());
    return $same_gateway && $same_amount;
  }

  /**
   * Discards a payment by voiding and deleting it.
   *
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   The payment.
   * @param bool $is_new
   *   Whether the payment is newly created or not.
   */
  protected function discardPayment(PaymentInterface $payment, $is_new) {
    if ($is_new) {
      // If the payment is new, it's state is 'new' and no transaction is
      // created for it yet, hence no need to void the payment, just delete it.
      $payment->delete();
      return;
    }

    try {
      // Void the stale payment which state is 'authorization'.
      if ($this->entityId == $payment->getPaymentGatewayId()) {
        // Same payment gateway implies same plugin type (i.e. plugin_id),
        // do it in this plugin instance.
        $void_response = $this->doVoidPayment($payment);
      }
      else {
        // Get the payment gateway plugin.
        $payment_gateway_plugin = $payment->getPaymentGateway()->getPlugin();
        if ($payment_gateway_plugin instanceof CNPaymentGatewayBase) {
          // Can do it directly through doVoidPayment() which is expected
          // and has few side effects.
          $void_response = $payment_gateway_plugin->doVoidPayment($payment);
        }
        elseif ($payment_gateway_plugin instanceof SupportsVoidsInterface){
          // Have to do a complete voiding which may have side effects such
          // as updating payment state and saving payment, it's not expected
          // because the payment is to be deleted.
          $payment_gateway_plugin->voidPayment($payment);
        }
        // Nothing else we can do because the payment is not voidable.
      }
      if (isset($void_response)) {
        $this->logResponse('Void payment', $void_response, $this->getOutTradeNo($payment));
      }
    }
    catch (RequestException $e) {
      // Log an error instead since this operation is a sub operation.
      $this->logger->error('@gateway Could not void payment: @message', [
        '@gateway' => $this->getLabel(),
        '@message' => $e->getMessage(),
      ]);
    }
    finally {
      // Delete the payment object anyway to avoid reusing it next time even
      // an exception is thrown.
      $payment->delete();
    }
  }

  /**
   * Whether the prepay response is successful.
   *
   * @param array $prepay_response
   *   The prepay response.
   *
   * @return bool
   *   TRUE on success, FALSE otherwise.
   */
  abstract protected function isPrepaySuccessful($prepay_response);

  /**
   * Performs prepay of the payment.
   *
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   The payment.
   * @param array $params
   *   (Optional) The prepay params.
   *
   * @return array
   *   An array of response data.
   *
   * @throws \GuzzleHttp\Exception\RequestException
   *   Thrown when the http request fails.
   */
  abstract protected function doPrepayPayment(PaymentInterface $payment, array $params = NULL);

  /**
   * Gets the payment subject with the given out trade no.
   *
   * @param string $out_trade_no
   *
   * @return string
   *   The payment subject.
   */
  protected function getPaymentSubject($out_trade_no) {
    return $this->configFactory->get('system.site')->get('name') . $this->t(' Order: ') . $out_trade_no;
  }

  /**
   * {@inheritdoc}
   */
  public function queryPayment(PaymentInterface $payment) {
    try {
      $query_response = $this->doQueryPayment($payment);
      $this->logResponse('Query payment', $query_response, $this->getOutTradeNo($payment));
    }
    catch (RequestException $e) {
      throw new PaymentGatewayException(sprintf('%s Could not query payment: %s', $this->getLabel(), $e->getMessage()), $e->getCode(), $e);
    }

    return $query_response;
  }

  /**
   * Performs query of the payment.
   *
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   The payment.
   *
   * @return array
   *   An array of response data.
   *
   * @throws \GuzzleHttp\Exception\RequestException
   *   Thrown when the http request fails.
   */
  abstract protected function doQueryPayment(PaymentInterface $payment);

  /**
   * {@inheritdoc}
   */
  public function refundPayment(PaymentInterface $payment, Price $amount = NULL) {
    $this->assertPaymentState($payment, ['completed', 'partially_refunded']);
    // If not specified, refund the entire amount.
    $amount = $amount ?: $payment->getAmount();
    $this->assertRefundAmount($payment, $amount);

    try {
      // Refund (full or partial) an transaction.
      $refund_response = $this->doRefundPayment($payment, $amount);
      $this->logResponse('Refund payment', $refund_response, $this->getOutTradeNo($payment));
    }
    catch (RequestException $e) {
      throw new PaymentGatewayException(sprintf('%s Could not refund payment: %s', $this->getLabel(), $e->getMessage()), $e->getCode(), $e);
    }

    // Throws when the transaction fails for any reason, see SupportsRefundsInterface.
    if (!$this->isResponseSuccessful($refund_response)) {
      throw new PaymentGatewayException($this->getResponseError($refund_response));
    }

    // Check if the Refund is partial or full.
    $old_refunded_amount = $payment->getRefundedAmount();
    $new_refunded_amount = $old_refunded_amount->add($amount);
    if ($new_refunded_amount->lessThan($payment->getAmount())) {
      $payment->setState('partially_refunded');
      $payment->setRemoteState($this->getRemoteState(self::STATE_PARTIAL_REFUND));
    }
    else {
      $payment->setState('refunded');
      $payment->setRemoteState($this->getRemoteState(self::STATE_REFUND));
    }
    $payment->setRefundedAmount($new_refunded_amount);

    // Save the payment.
    $payment->save();
  }

  /**
   * Performs refund of the payment.
   *
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   The payment.
   * @param \Drupal\commerce_price\Price $amount
   *   The amount.
   *
   * @return array
   *   The response array.
   *
   * @throws \GuzzleHttp\Exception\RequestException
   *   Thrown when the http request fails.
   */
  abstract protected function doRefundPayment(PaymentInterface $payment, Price $amount);

  /**
   * {@inheritdoc}
   */
  public function voidPayment(PaymentInterface $payment) {
    $this->assertPaymentState($payment, ['authorization']);

    try {
      $void_response = $this->doVoidPayment($payment);
      $this->logResponse('Void payment', $void_response, $this->getOutTradeNo($payment));
    }
    catch (RequestException $e) {
      throw new PaymentGatewayException(sprintf('%s Could not void payment: %s', $this->getLabel(), $e->getMessage()), $e->getCode(), $e);
    }

    // Throws when the transaction fails for any reason, see SupportsVoidsInterface.
    if (!$this->isResponseSuccessful($void_response)) {
      throw new PaymentGatewayException($this->getResponseError($void_response));
    }

    $payment->setState('authorization_voided');
    $payment->setRemoteState($this->getRemoteState(self::STATE_CLOSED));
    $payment->save();
  }

  /**
   * Performs void of the payment.
   *
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   The payment.
   *
   * @return array
   *   The response array.
   *
   * @throws \GuzzleHttp\Exception\RequestException
   *   Thrown when the http request fails.
   */
  abstract protected function doVoidPayment(PaymentInterface $payment);

  /**
   * {@inheritdoc}
   */
  public function getNotifyUrl() {
    if ($this->getMode() !== 'live') {
      // For other modes always assume the scheme is 'http'.
      $uri = 'http://' . $this->configuration['dev_notify_domain'] . '/payment/notify/' . $this->entityId;
      return Url::fromUri($uri, ['absolute' => TRUE]);
    }
    return parent::getNotifyUrl();
  }

  /**
   * Logs response.
   *
   * @param string $operation
   *   The operation
   * @param array $response
   *   An array of response data.
   * @param string $out_trade_no
   *   The out trade no.
   * @param bool $warning
   *   Show warning message.
   */
  protected function logResponse($operation, array $response, $out_trade_no, $warning = FALSE) {
    // if ($warning || $this->getMode() !== 'live') {
    $level = $warning ? 'warning' : 'debug';
    $this->logger->$level('@gateway @operation of @out_trade_no: <pre>@response</pre>', [
      '@gateway' => $this->getLabel(),
      '@operation' => $operation,
      '@out_trade_no' => $out_trade_no,
      '@response' => print_r($response, TRUE),
    ]);
    // }
  }

  /**
   * Logs the IPN Ignore message.
   *
   * @param array $ipn_data
   *   The IPN data.
   * @param string $trade_no_key
   *   The out trade no key.
   * @param string $reason
   *   The IPN ignored reason.
   */
  protected function logIpnIgnored(array $ipn_data, $trade_no_key, $reason) {
    $this->logger->warning('@gateway IPN Ignored for order @out_trade_no: @reason.', [
      '@gateway' => $this->getLabel(),
      '@out_trade_no' => $ipn_data[$trade_no_key],
      '@reason' => $reason,
    ]);
  }

  /**
   * {@inheritdoc}
   */
  public function loadPaymentByOutTradeNo($out_trade_no) {
    $storage = $this->entityTypeManager->getStorage('commerce_payment');
    return $storage->load(self::getPaymentId($out_trade_no));
  }

  /**
   * {@inheritdoc}
   */
  public function loadOrderByOutTradeNo($out_trade_no) {
    /** @var \Drupal\commerce_order\OrderStorage $storage */
    $storage = $this->entityTypeManager->getStorage('commerce_order');
    return $storage->load(self::getOrderId($out_trade_no));
  }

  /**
   * {@inheritdoc}
   */
  public function getOutTradeNo(PaymentInterface $payment) {
    $order_id = $payment->getOrderId();
    $payment_id = $payment->id();
    $mode = $payment->getPaymentGatewayMode() ?: $this->getMode();
    if (empty($order_id) || empty($payment_id)) {
      throw new \InvalidArgumentException('Both order id and payment id can not be empty');
    }
    $ids = [$order_id, $payment_id];
    if ($mode !== 'live') {
      $ids[] = self::getModeSuffix($mode);
    }
    return implode('_', $ids);
  }

  /**
   * {@inheritdoc}
   *
   * @todo: out_refund_no with request time?
   *
   * Note: append a time() since one order could be refunded multiple times but
   * one refund no only take effect once.
   *
   * @link https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_4
   */
  public function getOutRefundNo(PaymentInterface $payment) {
    $payment_id = $payment->id();
    $mode = $payment->getPaymentGatewayMode() ?: $this->getMode();
    $ids = [$payment_id, $this->time->getRequestTime()];
    if ($mode !== 'live') {
      $ids[] = self::getModeSuffix($mode);;
    }
    return implode('_', $ids);
  }

  /**
   * Gets the mode suffix.
   *
   * @param $mode
   *   The mode.
   * @return string
   *   The suffix.
   */
  private static function getModeSuffix($mode) {
    return str_replace(['-', '_'], '',  $mode . substr(Settings::getHashSalt(), 0, 4));
  }

  /**
   * Gets an order id from the given out trade no.
   *
   * @param string $out_trade_no
   *   The out trade no.
   *
   * @return int|string
   *   The order id.
   */
  private static function getOrderId($out_trade_no) {
    list($order_id) = explode('_', $out_trade_no);
    return $order_id;
  }

  /**
   * Gets a payment id from the given out trade no.
   *
   * @param string $out_trade_no
   *   The out trade no.
   *
   * @return int|string
   *   The payment id.
   */
  private static function getPaymentId($out_trade_no) {
    list(, $payment_id) = explode('_', $out_trade_no);
    return $payment_id;
  }

  /**
   * Gets remote state.
   *
   * @param $state_type
   *   The remote state type.
   *
   * @return string
   *   The remote state.
   *
   * @throws \InvalidArgumentException
   *   Thrown when the given state type is not recognized.
   */
  abstract protected function getRemoteState($state_type);

}
